<!DOCTYPE html>
<html lang="ru">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Введение к криптографию за 2 часа</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/6.0.0/normalize.min.css">
  <link rel="stylesheet" href="2hc.css">
</head>

<body>
  <h1>Введение к криптографию за 2 часа</h1>
  <p>На <a href="https://academy.yandex.ru/events/system_administration/kit_2014/">Яндекс.КИТ</a> в 2014 году я прочитал вводную
  лекцию по криптографии за 2 часа (видео <a href="https://www.youtube.com/watch?v=mE_s-R5wvpw">первой</a> и <a
  href="https://www.youtube.com/watch?v=M_Ohbwoxf-E">второй</a> частей). Потом мне показалось, что это хорошая идея&nbsp;&mdash;
  написать вводный материал по этой теме, который можно было бы изучить за пару часов и получить базовое представление.
  Большинство литературы на русском&nbsp;&mdash; учебники для ВУЗов, предполагающие наличие у читателя математической подготовки.
  Популярной книге Брюса Шнайера &laquo;Прикладная Криптография&raquo; уже больше 25 лет и местами она устарела.
  Поэтому, когда Яндекс опубликовал
  <a href="https://habrahabr.ru/company/yandex/blog/324866/">расшифровку лекции</a>, я решил доработать текст и выложить его в
  общий доступ.</p>

  <p>Вот что получилось.</p>

  <p>Эта работа предназначена для людей, не имеющих представления о криптографии&nbsp;&mdash; разделе математики, изучающем
  обеспечение конфиденциальности, целостности и проверку подлинности текстов. Я постарался объяснять материал простым языком,
  иногда поверхностно, но по возможности оставлять ссылки на дополнительные материалы. В первой части текста будут описаны
  некоторые <em>криптографические примитивы</em>, простые элементы, из которых впоследствии получаются более сложные конструкции,
  протоколы. Они будут описаны во второй части.</p>

  <h2>Криптографические примитивы</h2>

  <p>Мы будем говорить о трех примитивах: симметричном шифровании, аутентификации сообщений и ассиметричном шифровании. Из них
  вырастает очень много протоколов. Также мы обсудим, как вырабатываются ключи шифрования.</p>

  <p>Одним из фундаменальных принципов криптографии является
  <a href="https://ru.wikipedia.org/wiki/Принцип_Керкгоффса">принцип Керкгоффса</a>, который
  говорит, что криптографическая система должна сохранять в секрете только криптографические ключи. Система должна оставаться
  стойкой, даже если все детали её функционирования, кроме ключей, раскрыты.</p>

  <p>Поэтому, современные коммерчески доступные системы шифрования — все или почти
  все, или лучшие из них — построены из компонент,
  устройство и принцип работы которых хорошо известны. Единственная секретная вещь в них — ключ шифрования. Есть только одно
  известное мне значимое исключение — набор секретных криптографических протоколов для всевозможных государственных организаций. В
  США это называется <a href="https://en.wikipedia.org/wiki/NSA_Suite_A_Cryptography">NSA suite A</a>, а в России это всякие странные секретные алгоритмы шифрования, которые до определенной степени
  используются военными и государственными органами.</p>

  <p>Я не уверен, что такие алгоритмы приносят им большую пользу, за исключением того, что это примерно как атомная физика. Можно
  попытаться по пониманию дизайна протокола понять направление мысли людей, которые его разработали, и неким образом обогнать
  другую сторону. Не знаю, насколько такой принцип актуален по нынешним меркам, но люди, знающие про это больше меня, поступают
  именно так.</p>

  <h2>Симметричные шифры</h2>

  <p>Первый криптографический примитив — симметричные шифры.</p>
  <img alt="Блок-схема зашифровки" src=
  "https://habrastorage.org/files/7a7/309/454/7a7309454bfd4186b17414f42bdcc455.jpg">

  <p>Они очень простые. У нас есть какой-то алгоритм, на вход которого поступает открытый текст и нечто, называемое ключом,
  какое-то значение. На выходе получается зашифрованное сообщение. Когда мы хотим его дешифровать, важно, чтобы мы брали тот же
  самый ключ шифрования. И, применяя его к другому алгоритму, алгоритму расшифровки, мы из шифротекста получаем наш открытый текст
  назад.</p><img alt="Блок-схема расшифровки" src=
  "https://habrastorage.org/files/755/8f7/2db/7558f72db31e493894211e82dfddecfe.jpg">

  <p>Какие здесь важные нюансы? В большинстве распространенных алгоритмов симметричного шифрования, с которыми можно столкнуться,
  размер шифротекста всегда равен размеру открытого текста. Современные алгоритмы шифрования оперируют размерами ключей. Размер
  ключей измеряется в битах. Современный размер — от 128 до 256 бит для алгоритмов симметричного шифрования. Об остальном, в том
  числе о размере блока, мы поговорим позже.</p>

  <ul>
    <li>Для любого фиксированного ключа <em>k</em>, <em>E<sub>k</sub></em> является биективной функцией на множестве блоков</li>

    <li>Типичный размер блока&nbsp;— 128 бит</li>

    <li>Типичные размеры ключей&nbsp;— 128 или 256 бит</li>
  </ul>

  <p>Исторически, в условном IV веке до нашей эры, существовало два метода дизайна шифров: шифры подстановки и перестановки. Шифры
  подстановки — алгоритм, где в те времена заменяли одну букву сообщения на другую по какому-то принципу. Простой шифр подстановки
  — по таблице: берем таблицу, где написано, что А меняем на Я, Б на Ю и т. д. Дальше по этой таблице шифруем, по ней же
  дешифруем.</p>

  <p>Попробуем оценить, насколько сложен этот алгоритм с точки зрения размера пространства ключей. Сколько вариантов ключей
  существует? Чтобы ответить на этот вопрос, расмотрим, как мы строим таблицу замен.  Допустим, есть таблица на 33 символа. Букву
  &laquo;А&raquo; можем заменить на любой из них, букву &laquo;Б&raquo; — на любой из оставшихся 32, &laquo;В&raquo;&nbsp;&mdash;
  на любой из оставшихся. Получаем 33*32*31… — то есть факториал от 33.  Факториал размерности алфавита. Формально,
 log<sub>2</sub>33!&asymp;123, такой алгоритм имеет простраство ключей около 123 бит. В настоящее время
  считаются приемлемыми размеры ключей больше 100 бит. Иначе говоря, по этому признаку алгоритм мог бы считаться вполне надёжным.
  При этом, все, наверное, сталкивались с детстве с простой заменой и знают, что атака на него тривиальна.</p>

  <p>Долго существовали всякие алгоритмы подстановки в разных конструкциях. Одним из них, еще более примитивным, является шифр
  Цезаря, где таблица формируется не случайной перестановкой символов, а сдвигом на три символа: А меняется на D, B на Е и т. д.
  Понятно, что шифр Цезаря вместе со всеми его вариантами перебрать очень легко: в отличие от табличной подстановки, в ключе Цезаря
  всего 25 вариантов при 26 буквах в алфавите — не считая тривиального шифрования самого в себя. И его как раз можно перебрать
  полным перебором. Здесь есть некоторая сложность.</p>

  <p>Почему шифр табличной подстановки такой простой? Откуда возникает проблема, при которой мы можем легко, даже не зная ничего
  про криптографию, расшифровать табличную подстановку? Дело в частотном анализе. Есть самые распространенные буквы — какая-нибудь
  И или Е. Их распространенность велика, гласные встречаются намного чаще, чем согласные, и существуют негативные пары, никогда не
  встречающиеся в естественных языках, — что-то вроде ЬЪ. Я даже давал студентам задание сделать автоматический дешифратор шифра
  подстановки, и, в принципе, многие справлялись.</p>

  <p>В чем проблема? Надо статистику распределения букв исказить, чтобы распространенные буквы не так светились в зашифрованном
  тексте. Очевидный способ: давайте будем шифровать самые часто встречающиеся буквы не в один символ, а в пять разных, например.
  Если буква встречается в среднем в пять раз чаще, то давайте по очереди — сначала в первый символ будем зашифровывать, потом во
  второй, в третий и т. д. Далее у нас получится маппинг букв не 1 к 1, а, условно, 26 к 50. Статистика, таким образом, нарушится.
  Перед нами первый пример полиалфавитного шифра, который как-то работал. Однако с ним есть довольно много проблем, а главное,
  очень неудобно работать с таблицей.</p>

  <p>Дальше придумали: давайте не будем шифровать такими таблицами, а попробуем брать шифр Цезаря и для каждой следующей буквы
  изменять сдвиг. Результат — шифр Виженера.</p>

  <p>Берем в качестве ключа слово ВАСЯ. Берем сообщение МАША. Задействуем шифр Цезаря, но отсчитывая от этих букв. Например, В —
  третья буква в алфавите. Мы должны сдвинуть на три буквы соответствующую букву в открытом тексте. М сдвигается в О. А в А. Ш — на
  19, Й. Я сдвинет А в Я. ОАЙЯ.</p>

  <p>Что удобно в получившемся шифре? Здесь было две одинаковых буквы, но в результате они зашифровались в разные. Это классно,
  потому что размывает статистику. Метод хорошо работал, пока где-то в XIX веке, буквально недавно на фоне истории криптографии, не
  придумали, как его ломать. Если посмотреть на сообщение из нескольких десятков слов, а ключ довольно короткий, то вся конструкция
  выглядит как несколько шифров Цезаря. Мы говорим: окей, давайте каждую четвертую букву — первую, пятую, девятую — рассматривать
  как шифр Цезаря. И поищем среди них статистические закономерности. Мы обязательно их найдем. Потом возьмем вторую, шестую,
  десятую и так далее. Опять найдем. Тем самым мы восстановим ключ. Единственная проблема — понять, какой он длины. Это не очень
  сложно, ну какой он может быть длины? Ну 4, ну 10 символов. Перебрать 6 вариантов от 4 до 10 не очень сложно. Простая атака — она
  была доступна и без компьютеров, просто за счет ручки и листа бумаги.</p>

  <p>Как из этой штуки сделать невзламываемый шифр? Взять ключ размера текста. <a href="https://ru.wikipedia.org/wiki/Шеннон,_Клод">Клод Шеннон</a> в 1949
  году, написал <a href="shannon1949.pdf">классическую работу по криптографии</a> как по разделу математики, где сформулировал теорему. Длина ключа равна
  длине сообщения — он использовал XOR вместо сложения по модулю, равному длине алфавита, но в данной ситуации это не очень
  принципиально. Ключ сгенерирован случайным образом, является последовательностью случайных бит, и на выходе тоже получится
  случайная последовательность бит. Теорема: если у нас есть такой ключ, то подобная конструкция является абсолютно стойкой.
  Доказательство не очень сложное, но сейчас не буду про него говорить.</p>

  <p>Важно, что можно создать невзламываемый шифр, но у него есть недостатки. Во-первых, ключ должен быть абсолютно случайным.
  Во-вторых, он никогда не должен использоваться повторно. В-третьих, длина ключа должна быть равна длине сообщения. Почему нельзя
  использовать один и тот же ключ для шифровки разных сообщений? Потому что, перехватив этот ключ в следующий раз, можно будет
  расшифровать все сообщения? Нет. В первых символах будет виден шифр Цезаря? Не очень понял. Кажется, нет.</p>

  <p>Возьмем два сообщения: МАША, зашифрованная ключом ВАСЯ, и другое слово, у которого ключ тоже был ВАСЯ, — ВЕРА. Получим
  примерно следующее: ЗЕШЯ. Сложим два полученных сообщения, причем так, чтобы два ключа взаимно удалились. В итоге получим лишь
  разницу между осмысленным шифротекстом и осмысленным шифротекстом. На XOR это делается удобнее, чем на сложении по длине
  алфавита, но разницы практически никакой.</p>

  <p>Если мы получили разницу между двумя осмысленными шифротекстами, то дальше, как правило, становится намного легче, поскольку у
  текстов на естественном языке высокая избыточность. Зачастую мы можем догадаться, что происходит, делая разные предположения,
  гипотезы. А главное, что каждая верная гипотеза будет раскрывать нам кусочек ключа, а значит и кусочки двух шифротекстов. Как-то
  так. Поэтому плохо.</p>

  <p>Помимо шифров подстановки, были еще шифры перестановки. С ними тоже все довольно просто. Берем сообщение ВАСЯИ, записываем его
  в блок какой-то длины, например в ДИДОМ, и считываем результат так же.</p>

  <p>Не бог весть какая штука. Как ее ломать, тоже понятно — переберем все возможные варианты перестановок. Тут их не очень много.
  Берем длину блока, подбираем и восстанавливаем.</p>

  <p>В качестве следующей итерации был выбран такой способ: возьмем все то же самое, а сверху напишем какой-нибудь ключ — СИМОН.
  Переставим столбцы так, чтобы буквы оказались в алфавитном порядке. В итоге получим новую перестановку по ключу. Она уже намного
  лучше старой, поскольку количество перестановок намного больше и подобрать ее не всегда легко.</p>

  <p>Каждый современный шифр тем или иным способом базируется на этих двух принципах — подстановки и перестановки. Сейчас их
  использование намного более сложное, но сами базовые принципы остались прежними.</p>

  <p><img alt="Схема работы поточного шифра" src=
  "https://habrastorage.org/files/cf1/961/778/cf19617788074743b6f8f5868317f254.jpg"></p>

  <p>Если говорить про современные шифры, они делятся на две категории: поточные и блочные. Поточный шифр устроен так, что
  фактически представляет собой генератор случайных чисел, выход которого мы складываем по модулю 2, «ксорим», с нашим
  шифротекстом, как видно у меня на слайде. Ранее я сказал: если длина получившегося ключевого потока — она же ключ — абсолютно
  случайная, никогда повторно не используется и ее длина равна длине сообщения, то у нас получился абсолютно стойкий шифр,
  невзламываемый.</p>

  <p>Возникает вопрос: как сгенерировать на такой шифр случайный, длинный и вечный ключ? Как вообще работают поточные шифры? По
  сути, они представляют собой генератор случайного числа на основе какого-то начального значения. Начальное значение и является
  ключом шифра, ответом.</p>

  <p>Из этой истории есть одно занятное исключение — шифроблокноты. Речь идет о настоящей шпионской истории про настоящий шпионаж.
  Некие люди, которым нужна абсолютно устойчивая коммуникация, генерируют случайные числа — например, буквальным бросанием кубика
  или буквальным выниманием шаров из барабана, как в лото. Создают два листа, где печатают эти случайные числа. Один лист отдают
  получателю, а второй оставляют у отправителя. При желании пообщаться они используют этот поток случайных чисел в качестве
  ключевого потока. Нет, история взята не из совсем далекого прошлого. У меня есть настоящий радиоперехват от 15 октября 2014 года:
  7 2 6, 7 2 6, 7 2 6. Это позывной. 4 8 3, 4 8 3, 4 8 3. Это номер шифроблокнота. 5 0, 5 0, 5 0. Это количество слов. 8 4 4 7 9 8
  4 4 7 9 2 0 5 1 4 2 0 5 1 4 и т. д. 50 таких числовых групп. Не знаю где, где-то не в России сидел какой-нибудь человек с ручкой
  и карандашом у обычного радиоприемника и записывал эти цифры. Записав их, он достал похожую штуку, сложил их по модулю 10 и
  получил свое сообщение. Другими словами, это реально работает, и подобное сообщение нельзя взломать. Если действительно были
  сгенерированы хорошие случайные числа и он впоследстии сжег бумажку с ключом, то осуществить взлом нельзя никак, совсем.</p>

  <p>Но тут есть довольно много проблем. Первая — как нагенерировать по-настоящему хорошие случайные числа. Мир вокруг нас
  детерминирован, и если мы говорим про компьютеры, они детерминированы полностью.</p>

  <p>Во-вторых, доставлять ключи такого размера… если мы говорим про передачу сообщений из 55 цифровых групп, то проделать подобное
  не очень сложно, а вот передать несколько гигабайт текста — уже серьезная проблема. Следовательно, нужны какие-нибудь алгоритмы,
  которые, по сути, генерируют псевдослучайные числа на основе какого-нибудь небольшого начального значения и которые могли бы
  использоваться в качестве таких потоковых алгоритмов.</p>
  
  <h3>Шифр RC4</h3>

  <img alt="Схема работы шифра RC4" src=
  "https://habrastorage.org/files/638/a94/d2a/638a94d2a34341feaaef3929c88200ad.jpg">

  <p>Самый исторически распространенный алгоритм подобного рода называется RC4. Он был разработан Роном Ривестом лет 25 назад и
  активно использовался очень долго, был самым распространенным алгоритмом для TLS, всех его различных вариантов, включая HTTPS. Но
  в последнее время RC4 начал показывать свой возраст. Для него существует некоторое количество атак. Он активно используется в
  WEP. Была <a href="https://events.yandex.ru/lib/talks/523/">одна хорошая лекция Антона</a>, история, которая показывает: плохое
  применение пристойного даже по нынешним меркам алгоритма шифрования приводит к тому, что компрометируется вся система.</p>

  <p>RC4 устроен несложно. На слайде целиком описана его работа. Есть внутренний байтовый стейт из 256 байт. На каждом шаге этого
  стейта есть два числа, два указателя на разные байты в стейте. И на каждом шаге происходит сложение между этими числами — они
  помещаются в некоторое место стейта. Полученный оттуда байт является следующим байтом в числовой последовательности. Вращая эту
  ручку таким образом, выполняя подобное действие на каждом шаге, мы получаем каждый следующий байт. Мы можем получать следующий
  байт числовой последовательности вечно, потоком.</p>

  <p>Большое достоинство RC4 — в том, что он целиком внутрибайтовый, а значит, его программная реализация работает довольно быстро
  — сильно быстрее, в разы, если не в десятки раз быстрее, чем сравнимый и существовавший примерно в одно время с ним шифр DES.
  Поэтому RC4 и получил такое распространение. Он долго был коммерческим секретом компании RSA, но потом, где-то в районе 90-х
  годов, некие люди анонимно опубликовали исходники его устройства в списке рассылки cypherpunks. В результате возникло много
  драмы, были крики, мол, как же так, какие-то неприличные люди украли интеллектуальную собственность компании RSA и опубликовали
  ее. RSA начала грозить всем патентами, всевозможными юридическими преследованиями. Чтобы их избежать, все реализации алгоритма,
  которые находятся в опенсорсе, называются не RC4, а ARC4 или ARCFOUR. А — alleged. Речь идет о шифре, который на всех тестовых
  кейсах совпадает с RC4, но технически вроде как им не является.</p>

  <p>Если вы конфигурируете какой-нибудь SSH или OpenSSL, вы в нем не найдете упоминания RC4, а найдете ARC4 или что-то подобное.
  Несложная конструкция, он уже старенький, на него сейчас есть атаки, и он не очень рекомендуется к использованию.</p>
  
  <h3>Шифр Salsa20</h3>
  
  <img alt=
  "Схема работы шифра Slasa20" src="https://habrastorage.org/files/e23/88d/a62/e2388da622d24baf817334e07f686eb5.jpg">

  <p>Было несколько попыток его заменить. Наверное, на мой предвзятый взгляд самым успешным стал шифр Salsa20 и несколько его
  последователей от широкого известного в узких кругах персонажа Дэна Берштайна. Линуксоидам он обычно известен как автор
  qmail.</p>

  <p>Salsa20 устроен сложнее, чем DES. Его блок-схема сложная, но он обладает несколькими интересными и классными свойствами. Для
  начала, он всегда выполняется за конечное время, каждый его раунд, что немаловажно для защиты от тайминг-атак. Это такие атаки,
  где атакующий наблюдает поведение системы шифрования, скармливая ей разные шифротексты или разные ключи за этим черным ящиком. И,
  понимая изменения во времени ответа или в энергопотреблении системы, он может делать выводы о том, какие именно процессы
  произошли внутри. Если вы думаете, что атака сильно надуманная, это не так. Очень широко распространены атаки подобного рода на
  смарт-карты — очень удобные, поскольку у атакующего есть полный доступ к коробке. Единственное, что он, как правило, не может в
  ней сделать, — прочитать сам ключ. Это сложно, а делать все остальное он может — подавать туда разные сообщения и пытаться их
  расшифровать.</p>

  <p>Salsa20 устроен так, чтобы он всегда выполнялся за константное одинаковое время. Внутри он состоит всего из трех примитивов:
  это сдвиг на константное время, а также сложение по модулю 2 и по модулю 32, 32-битных слов. Скорость Salsa20 еще выше, чем у
  RC4. Он пока что не получил такого широкого распространения в общепринятой криптографии — у нас нет cipher suite для TLS,
  использующих Salsa20, — но все равно потихоньку становится мейнстримом. Указанный шифр стал одним из победителей конкурса eSTREAM
  по выбору лучшего поточного шифра. Их там было четыре, и Salsa — один из них. Он потихоньку начинает появляться во всяких
  опенсорс-продуктах. В частности, в <a href="https://tools.ietf.org/html/rfc7539">RFC7539</a> описана AEAD конструкция на основе
  ChaCha20, потомка шифра Salsa20 и аутентификатора Poly1305. В <a href="https://tools.ietf.org/html/rfc7905">RFC7905</a> описано
  использование этой конструкции в TLS.</p>

  <p>На него имеется некоторое количество криптоанализа, есть даже атаки. Снаружи он выглядит как поточный, генерируя на основе
  ключа последовательность почти произвольной длины, 2<sup>64</sup>. Зато внутри он работает как блочный. В алгоритме есть место,
  куда можно подставить номер блока, и он выдаст указанный блок.</p>

  <p>Какая проблема с поточными шифрами? Если у вас есть поток данных, передаваемый по сети, поточный шифр для него удобен. К вам
  влетел пакет, вы его зашифровали и передали. Влетел следующий — приложили эту гамму и передали. Первый байт, второй, третий по
  сети идут. Удобно.</p>

  <p>Если данные, например гигабайтный файл целиком, зашифрованы на диске поточным шифром, то чтобы прочитать последние 10 байт,
  вам нужно будет сначала сгенерировать гаммы потока шифра на 1 гигабайт, и уже из него взять последние 10 байт. Очень
  неудобно.</p>

  <p>В Salsa указанная проблема решена, поскольку в нем на вход поступает в том числе и номер блока, который надо сгенерировать.
  Дальше к номеру блока 20 раз применяется алгоритм. 20 раундов — и мы получаем 512 бит выходного потока.</p>

  <p>Самая успешная атака — в 8 раундов. Сам он 256-битный, а сложность атаки в 8 раундов — 250 или 251 бит. Считается, что он
  очень устойчивый, хороший. Публичный криптоанализ на него есть. Несмотря на всю одиозность личности Берштайна в этом аспекте, мне
  кажется, что штука хорошая и у нее большее будущее.</p>

  <p>Исторически поточных шифров было много. Они первые не только в коммерческом шифровании, но и в военном. Там использовалось то,
  что называлось линейными регистрами сдвига.</p>

  <p>Какие тут проблемы? Первая: в классических поточных шифрах, не в Salsa, чтобы расшифровать последнее значение гигабайтного
  файла, последний байт, вам нужно сначала сгенерировать последовательность на гигабайт. От нее вы задействуете только последний
  байт. Очень неудобно.</p>

  <p>Поточные шифры плохо пригодны для систем с непоследовательным доступом, самый распространенный пример которых — жесткий
  диск.</p>

  <p>Есть и еще одна проблема, о ней мы поговорим дальше. Она очень ярко проявляется в поточных шифрах. Две проблемы в совокупности
  привели к тому, что здорово было бы использовать какой-нибудь другой механизм.</p>

  <h3>Шифр DES</h3>

  <p>Другой механизм для симметричного шифрования называется блочным шифром. Он устроен чуть по-другому. Он не генерирует этот
  ключевой поток, который надо ксорить с нашим шифротекстом, а работает похоже — как таблица подстановок. Берет блок текста
  фиксированной длины, на выходе дает такой же длины блок текста, и всё.</p>

  <p>Размер блока в современных шифрах — как правило, 128 бит. Бывают разные вариации, но как правило, речь идет про 128 или 256
  бит, не больше и не меньше. Размер ключа — точно такой же, как для поточных алгоритмов: 128 или 256 бит в современных
  реализациях, от и до.</p>

  <p>Из всех широко распространенных блочных шифров сейчас можно назвать два — DES и AES. DES очень старый шифр, ровесник RC4. У
  DES сейчас размер блока — 64 бита, а размер ключа — 56 бит. Создан он был в компании IBM под именем Люцифер. Когда в IBM его
  дизайном занимался Хорст Фейстель, они предложили выбрать 128 бит в качестве размера блока. А размер ключа был изменяемый, от 124
  до 192 бит.</p>

  <p>Когда DES начал проходит стандартизацию, его подали на проверку в том числе и в АНБ. Оттуда он вернулся с уменьшенным до 64
  бит размером блока и уменьшенным до 56 бит размером ключа.</p>

  <p>Свойства DES</p>

  <ul>
    <li>Сеть Фейстеля</li>

    <li>Размер блока&nbsp;— 64 бита</li>

    <li>Размер ключа&nbsp;— 56 бит</li>

    <li>16 раундов</li>
  </ul><img alt="Схема работы раундовой функции DES" src=
  "https://habrastorage.org/files/24a/340/9c7/24a3409c72de46fd96e71d1bbf6c9605.jpg">

  <p>20 лет назад вся эта история наделала много шума. Все говорили — наверняка они туда встроили закладку, ужасно, подобрали такой
  размер блока, чтобы получить возможность атаковать. Однако большое достоинство DES в том, что это первый шифр, который был
  стандартизован и стал тогда основой коммерческой криптографии.</p>

  <p>Его очень много атаковали и очень много исследовали. Есть большое количество всевозможных атак. Но ни одной практически
  реализуемой атаки до сих пор нет, несмотря на его довольно почтенный возраст. Единственное, размер ключа в 56 бит сейчас просто
  неприемлемый и можно атаковать полным перебором.</p>

  <p>Как устроен DES? Фейстель сделал классную штуку, которую называют сетью Фейстеля. Она оперирует блоками. Каждый блок,
  попадающий на вход, делится на две части: левую и правую. Левая часть становится правой без изменений. Правая часть ксорится с
  результатом вычисления некой функции, на вход которой подается левая часть и ключ. После данного преобразования правая часть
  становится левой.</p>

  <p><img alt="Схема работы сети Фейстеля" src=
  "https://habrastorage.org/files/cb7/d53/487/cb7d534878e046ceb8aca7033100b001.jpg"></p>

  <p>У нее есть несколько интересных достоинств. Первое важное достоинство: функция F может быть любой. Она не должна обладать
  свойствами обратимости, она может и не быть линейной или нелинейной. Все равно шифр остается симметричным.</p>

  <p>Второе очень удобное свойство: расшифровка устроена так же, как шифрование. Если нужно расшифровать данную сеть, вы в прежний
  механизм вместо открытого текста засовываете шифротекст и на выходе вновь получаете открытый текст.</p>

  <p>Почему это удобно? 30 лет назад удобство являлось следствием того, что шифраторы были аппаратными и заниматься дизайном
  отдельного набора микросхем для шифрования и для расшифровки было трудоемко. А в такой конструкции все очень здорово, фактически
  мы можем один блок использовать для разных задач.</p>

  <p>В реальной ситуации такая конструкция — один раунд блочного шифра, то есть в реальном шифре она выполняется 16 раз с разными
  ключами. На каждом 16 раунде генерируется отдельный ключ и 16 раундовых подключей, каждый из которых применяется на каждом раунде
  для функции F.</p>

  <p>Раунд тоже выглядит довольно несложно — он состоит всего из двух-трех операций. Первая операция: размер попавшегося полублока
  становится равен 32 бита, полубок проходит функцию расширения, на вход попадает 32 бита. Дальше мы по специальной несекретной
  таблице немного добавляем к 32 битам, превращая их в 48: некоторые биты дублируются и переставляются, такая гребеночка.</p>

  <p>Потом мы его ксорим с раундовым ключом, размер которого — тоже 48 бит, и получаем 48-битное значение.</p>

  <p>Затем оно попадает в набор функций, которые называются S-боксы и преобразуют каждый бит входа в четыре бита выхода.
  Следовательно, на выходе мы из 48 бит снова получаем 32 бита.</p>

  <p>И наконец, окончательная перестановка P. Она опять перемешивает 32 бита между собой. Все очень несложно, раундовая функция
  максимально простая.</p>

  <p>Самое интересное ее свойство заключается в указанных S-боксах: задумано очень сложное превращение 6 бит в 4. Если посмотреть
  на всю конструкцию, видно, что она состоит из XOR и пары перестановок. Если бы S-боксы были простыми, весь DES фактически
  представлял бы собой некоторый набор линейных преобразований. Его можно было бы представить как матрицу, на которую мы умножаем
  наш открытый текст, получая шифротекст. И тогда атака на DES была бы тривиальной: требовалось бы просто подобрать матрицу.</p>

  <p>Вся нелинейность сосредоточена в S-боксах, подобранных специальным образом. Существуют разные анекдоты о том, как именно они
  подбирались. В частности, примерно через 10 лет после того, как DES был опубликован и стандартизован, криптографы нашли новый тип
  атак — дифференциальный криптоанализ. Суть атаки очень простая: мы делаем мелкие изменения в открытом тексте — меняя, к примеру,
  значение одного бита с 0 на 1 — и смотрим, что происходит с шифротекстом. Выяснилось, что в идеальном шифре изменение одного бита
  с 0 на 1 должно приводить к изменению ровно половины бит шифротекста. Выяснилось, что DES, хоть он и был сделан перед тем, как
  открыли дифференциальный криптоанализ, оказался устойчивым к этому типу атак. В итоге в свое время возникла очередная волна
  паранойи: мол, АНБ еще за 10 лет до открытых криптографов знало про существование дифференциального криптоанализа, и вы
  представляете себе, что оно может знать сейчас.</p>

  <p>Анализу устройства S-боксов посвящена не одна сотня статей. Есть классные статьи, которые называются примерно так: особенности
  статистического распределения выходных бит в четвертом S-боксе. Потому что шифру много лет, он досконально исследован в разных
  местах и остается достаточно устойчивым даже по нынешним меркам.</p>

  <p>56 бит сейчас уже можно просто перебрать на кластере машин общего назначения — может, даже на одном. И это плохо. Что можно
  предпринять?</p>

  <p>Просто сдвинуть размер ключа нельзя: вся конструкция завязана на его длину. Triple DES. Очевидный ответ был таким: давайте мы
  будем шифровать наш блок несколько раз, устроим несколько последовательных шифрований. И здесь всё не слишком тривиально.</p>

  <p>Допустим, мы берем и шифруем два раза. Для начала нужно доказать, что для шифрований k1 и k2 на двух разных ключах не
  существует такого шифрования на ключе k3, что выполнение двух указанных функций окажется одинаковым. Здесь вступает в силу
  свойство, что DES не является группой. Тому существует доказательство, пусть и не очень тривиальное.</p>

  <p>Окей, 56 бит. Давайте возьмем два — k1 и k2. 56 + 56 = 112 бит. 112 бит даже по нынешним меркам — вполне приемлемая длина
  ключа. Можно считать нормальным всё, что превышает 100 бит. Так почему нельзя использовать два шифрования, 112 бит?</p>

  <p>Одно шифрование DES состоит из 16 раундов. Сеть применяется 16 раз. Изменения слева направо происходят 16 раз. И он — не
  группа. Есть доказательство того, что не существует такого ключа k3, которым мы могли бы расшифровать текст, последовательно
  зашифрованный выбранными нами ключами k1 и k2.</p>

  <p>Есть атака. Давайте зашифруем все возможные тексты на каком-нибудь ключе, возьмем шифротекст и попытаемся его расшифровать на
  всех произвольных ключах. И здесь, и здесь получим 2<sup>56</sup> вариантов. И где-то они сойдутся. То есть за два раза по
  2<sup>56</sup> вариантов — плюс память для хранения всех расшифровок — мы найдем такую комбинацию k1 и k2, при которых атака
  окажется осуществимой.</p>

  <p>Эффективная стойкость алгоритма — не 112 бит, а 57, если у нас достаточно памяти. Нужно довольно много памяти, но тем не
  менее. Поэтому решили — так работать нельзя, давайте будем шифровать три раза: k1, k2, k3. Конструкция называется Triple DES.
  Технически она может быть устроена по-разному. Поскольку в DES шифрование и дешифрование — одно и то же, реальные алгоритмы
  иногда выглядят так: зашифровать, расшифровать и снова расшифровать — чтобы выполнять операции в аппаратных реализациях было
  проще.</p>

  <p>Наша обратная реализация Triple DES превратится в аппаратную реализацию DES. Это может быть очень удобно в разных ситуациях
  для задачи обратной совместимости.</p>

  <p>Где применялся DES? Вообще везде. Его до сих пор иногда можно пронаблюдать для TLS, существуют cipher suite для TLS,
  использующие Triple DES и DES. Но там он активно отмирает, поскольку речь идет про софт. Софт легко апдейтится.</p>

  <p>А вот в банкоматах он отмирал очень долго, и я не уверен, что окончательно умер. Не знаю, нужна ли отдельная лекция о том, как
  указанная конструкция устроена в банкоматах. Если коротко, клавиатура, где вы вводите PIN, — самодостаточная вещь в себе. В нее
  загружены ключи, и наружу она выдает не PIN, а конструкцию PIN-блок. Конструкция зашифрована — например, через DES. Поскольку
  банкоматов огромное количество, то среди них много старых и до сих пор можно встретить банкомат, где внутри коробки реализован
  даже не Triple DES, а обычный DES.</p>

  <h3>Шифр AES</h3>

  <p>Однажды DES стал показывать свой возраст, с ним стало тяжело, и люди решили придумать нечто поновее. Американская контора по
  стандартизации, которая называется NIST, сказала: давайте проведем конкурс и выберем новый классный шифр. Им стал AES.</p>

  <p>DES расшифровывается как digital encrypted standard. AES — advanced encrypted standard. Размер блока в AES — 128 бит, а не 64.
  Это важно с точки зрения криптографии. Размер ключа у AES — 128, 192 или 256 бит. В AES не используется сеть Фейстеля, но он тоже
  многораундовый, в нем тоже несколько раз повторяются относительно примитивные операции. Для 128 бит используется 10 раундов, для
  256 — 14.</p>

  <p>Сейчас покажу, как устроен каждый раунд. Первый и последний раунды чуть отличаются от стандартной схемы — тому есть
  причины.</p>

  <p>Как и в DES, в каждом раунде AES есть свои раундовые ключи. Все они генерируются из ключа шифрования для алгоритма. В этом
  месте AES работает так же, как DES. Берется 128-битный ключ, из него генерируется 10 подключей для 10 раундов. Каждый подключ,
  как и в DES, применяется на каждом конкретном раунде.</p>

  <p>Каждый раунд состоит из четырех довольно простых операций. Первый раунд — подстановка по специальной таблице.</p>

  <p>В AES мы строим байтовую матрицу размером 4 на 4. Каждый элемент матрицы — байт. Всего получается 16 байт или 128 бит. Они и
  составляют блок AES целиком.</p>

  <p>Вторая операция — побайтовый сдвиг.</p>

  <p>Устроен он несложно, примитивно. Мы берем матрицу 4 на 4. Первый ряд остается без изменений, второй ряд сдвигается на 1 байт
  влево, третий — на 2 байта, четвертый — на 3, циклично.</p>

  <p>Далее мы производим перемешивание внутри колонок. Это тоже очень несложная операция. Она фактически переставляет биты внутри
  каждой колонки, больше ничего не происходит. Можно считать ее умножением на специальную функцию.</p>

  <p>Четвертая, вновь очень простая операция — XOR каждого байта в каждой колонке с соответствующим байтом ключа. Получается
  результат.</p>

  <p>В первом раунде лишь складываются ключи, а три других операции не используются. В последнем раунде не происходит подобного
  перемешивания столбцов:</p>

  <p>Дело в том, что это не добавило бы никакой криптографической стойкости и мы всегда можем обратить последний раунд. Решили не
  тормозить конструкцию лишней операцией.</p>

  <p>Мы повторяем 4 описанных шага 10 раз, и на выходе из 128-битного блока снова получаем 128-битный блок.</p>

  <p>Какие достоинства у AES? Он оперирует байтами, а не битами, как DES. AES намного быстрее в софтовых реализациях. Если сравнить
  скорость выполнения AES и DES на современной машине, AES окажется в разы быстрее, даже если говорить о реализации исключительно в
  программном коде.</p>

  <p>Производители современных процессоров, Intel и AMD, уже разработали ассемблерные инструкции для реализации AES внутри чипа,
  потому что стандарт довольно несложный. Как итог — AES еще быстрее. Если через DES на современной машинке мы можем зашифровать,
  например, 1-2 гигабита, то 10-гигабитный AES-шифратор находится рядом и коммерчески доступен обычным компаниям.</p>

  <h3>Режимы шифрования</h3>

  <p>Блочный алгоритм шифрует блок в блок. Он берет блок на 128 или 64 бита и превращает его в блок на 128 или 64 бита.</p>

  <p>А что мы будем делать, если потребуется больше, чем 16 байт?</p>

  <p>Первое, что приходит в голову, — попытаться разбить исходное сообщение на блоки, а блок, который останется неполным, дополнить
  стандартной, известной и фиксированной последовательностью данных.</p>

  <p>Да, очевидно, побьем всё на блоки по 16 байт и зашифруем. Такое шифрование называется ECB — electronic code book, когда каждый
  из блоков по 16 байт в случае AES или по 8 байт в случае DES шифруется независимо.</p>

  <p><img alt="Схема работы режима ECB" src="https://habrastorage.org/files/ab2/e98/3d4/ab2e983d441f465bb3b2571120ebf31b.jpg"></p>

  <p>Шифруем каждый блок, получаем шифротекст, складываем шифротексты и получаем полный результат.</p>

  <p><img alt="Кртинка, зашифрованная в режиме ECB" src=
  "https://habrastorage.org/files/f5e/e97/c28/f5ee97c28db14fdeb64f86173fcdf2b2.jpg"></p>

  <p>Примерно так выглядит картинка, зашифрованная в режиме ECB. Даже если мы представим себе, что шифр полностью надежен, кажется,
  что результат менее чем удовлетворительный. В чем проблема? В том, что это биективное отображение. Для одинакового входа всегда
  получится одинаковый выход, и наоборот — для одинакового шифротекста всегда получится одинаковый открытый текст.</p>

  <p>Надо бы как-нибудь исхитриться и сделать так, чтобы результат на выходе все время получался разным, в зависимости от
  местонахождения блока — несмотря на то, что на вход подаются одинаковые блоки шифротекста. Первым способом решения стал режим
  CBC.</p>

  <p><img alt="Схема работы режима CBC" src="https://habrastorage.org/files/3c8/869/fdb/3c8869fdb5064faa97ba4e3b89dc1e02.jpg"></p>

  <p>Мы не только берем ключ и открытый текст, но и генерируем случайное число, которое не является секретным. Оно размером с блок.
  Называется оно инициализационным вектором.</p>

  <p>При шифровании первого блока мы берем инициализационный вектор, складываем его по модулю 2 с открытым текстом и шифруем. На
  выходе — шифротекст. Дальше складываем полученный шифротекст по модулю 2 со вторым блоком и шифруем. На выходе — второй блок
  шифротекста. Складываем его по модулю 2 с третьим блоком открытого текста и шифруем. На выходе получаем третий блок шифротекста.
  Здесь видно сцепление: мы каждый следующий блок сцепляем с предыдущим.</p>

  <p>В результате получится картинка, где всё, начиная со второго блока, равномерно размазано, а первый блок каждый раз зависит от
  инициализационного вектора. И она будет абсолютно перемешана. Здесь все неплохо.</p>

  <p>Однако у CBC есть несколько проблем.</p>

  <p>О размере блока. Представьте: мы начали шифровать и, допустим, у нас DES. Если бы DES был идеальным алгоритмом шифрования,
  выход DES выглядел бы как равномерно распределенные случайные числа длиной 64 бита. Какова вероятность, что в выборке из
  равномерно распределенных случайных чисел длиной 64 бита два числа совпадут для одной операции? 1/(2<sup>64</sup>). А если мы
  сравниваем три числа? Давайте пока прервемся.</p>
</body>
</html>
